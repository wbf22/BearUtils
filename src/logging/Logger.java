package logging;

import java.util.regex.Pattern;
import java.nio.charset.StandardCharsets;
import java.util.List;
import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.util.ArrayList;


/**
 * This file was generated by OneFile
 *
 * Repository: Logger
 *
 * This file contains all the classes in the repository
 */
public class Logger {


	private static List<String> logToFiles = new ArrayList<>();
	private static Level logLevel = Level.INFO;
	private static Formatter formatter = new DefaultFormatter();

	private Logger() { }


	/*
		global config methods
	 */
	public static void setApplicationLogLevel(Level level) {
		logLevel = level;
		Logger.info("Logger Level is set to " + logLevel.name());
	}

	public static void setLogFilePaths(List<String> paths) {
		logToFiles = paths;
	}

	public static void setFormatter(Logger.Formatter customFormatter) {
		formatter = customFormatter;
	}



	/*
		public methods
	 */

	public static void print(String message) {
		System.out.println( message );
	}

	public static void space() {
		print("");
		logToFiles.forEach(path ->
				appendToFile(
						path,
						"\n"
				));
	}

	public static void error(String message) {
		log(message, Level.ERROR);
	}

	public static void warning(String message) {
		log(message, Level.WARNING);
	}

	public static void info(String message) {
		log(message, Level.INFO);
	}

	public static void debug(String message) {
		log(message, Level.DEBUG);
	}

	public static void trace(String message) {
		log(message, Level.TRACE);
	}



	/*
		private methods
	 */
	private static void log(String message, Level level) {
		if (logLevel.isLoggable(level)) {
			String formattedMessage = formatMessage(level, message);
			print(formattedMessage);

			logToFiles.forEach(path ->
					appendToFile(
						path,
						AnsiColor.removeAnsiColors(formattedMessage) + "\n"
					));
		}
	}

	private static void appendToFile(String filePath, String message) {
		try (RandomAccessFile file = new RandomAccessFile(filePath, "rw")) {
			file.seek(file.length());
			file.write(message.getBytes(StandardCharsets.UTF_8));
		} catch (IOException e) {
			String errMsg = formatMessage(Level.ERROR, "Failure logging to log file: " + filePath);
			print(errMsg);
		}
	}

	private static String formatMessage(Level level, String message) {
		String levelTag = "[" + level.getAnsiColor() +  level.name() + AnsiColor.RESET + "] ";
		return levelTag + formatter.format(message);
	}





	/*
		individual logger config methods
	 */
	public Logger withFormatter(Formatter customFormatter) {
		this.formatter = customFormatter;
		return this;
	}





	/*
	 * Helper classes
	 */

	public static interface Formatter {
	
	
	    String format(String message);
	
	
	    // default String getTimeStampAlternate() {
	    //     ZonedDateTime date = ZonedDateTime.now();
	    //     return AnsiColor.BLACK_HIGH_INTENSITY.BOLD() + date.format(
	    //             DateTimeFormatter.ofPattern("yyyy-MM-dd ")
	    //     ) + AnsiColor.WHITE.DIM() + date.format(
	    //             DateTimeFormatter.ofPattern("HH:mm ")
	    //     ) + AnsiColor.BLACK_HIGH_INTENSITY + date.format(
	    //             DateTimeFormatter.ofPattern("ss.SS")
	    //     )  + "s " + date.format(
	    //             DateTimeFormatter.ofPattern("xx ")
	    //     ) + AnsiColor.WHITE.DIM() + date.format(
	    //             DateTimeFormatter.ofPattern("'['VV']'")
	    //     ) + AnsiColor.RESET;
	    // }
	
	
	    default String getTimeStamp() {
	        ZonedDateTime date = ZonedDateTime.now();
	        return AnsiColor.WHITE.ITALIC() + date.format(
	                DateTimeFormatter.ofPattern("yyyy-MM-dd ")
	        ) + AnsiColor.WHITE.DIM() + date.format(
	                DateTimeFormatter.ofPattern("HH:mm ")
	        ) + AnsiColor.WHITE.ITALIC() + date.format(
	                DateTimeFormatter.ofPattern("ss.SS")
	        )  + "s " + date.format(
	                DateTimeFormatter.ofPattern("xx ")
	        ) + AnsiColor.WHITE.DIM() + date.format(
	                DateTimeFormatter.ofPattern("'['VV']'")
	        ) + AnsiColor.RESET;
	    }
	
	}

	public enum Level {
	
	    ERROR(AnsiColor.RED.BOLD()),
	    WARNING(AnsiColor.YELLOW.BOLD()),
	    INFO(AnsiColor.BLUE.BOLD()),
	    DEBUG(AnsiColor.GREEN.BOLD()),
	    TRACE(AnsiColor.CYAN.BOLD());
	
	    private AnsiColor ansiColor;
	
	    Level(AnsiColor ansiColor) {
	        this.ansiColor = ansiColor;
	    }
	
	    public boolean isLoggable(Level level) {
	        return this.compareTo(level) >= 0;
	    }
	
	    public AnsiColor getAnsiColor() {
	        return ansiColor;
	    }
	
	    public java.util.logging.Level map() {
	        return switch(this) {
	            case ERROR -> java.util.logging.Level.SEVERE;
	            case WARNING -> java.util.logging.Level.WARNING;
	            case INFO -> java.util.logging.Level.INFO;
	            case DEBUG -> java.util.logging.Level.CONFIG;
	            case TRACE -> java.util.logging.Level.FINEST;
	        };
	    }
	
	
	}

	public enum AnsiColor {
	    //https://gist.github.com/JBlond/2fea43a3049b38287e5e9cefc87b2124
	
	    RESET(0),
	    BOXED(51),
	
	    // Regular Colors
	    BLACK(30),
	    RED(31),
	    GREEN(32),
	    YELLOW(33),
	    BLUE(34),
	    PURPLE(35),
	    CYAN(36),
	    WHITE(37),
	
	    // High Intensity Colors
	    BLACK_HIGH_INTENSITY(90),
	    RED_HIGH_INTENSITY(91),
	    GREEN_HIGH_INTENSITY(92),
	    YELLOW_HIGH_INTENSITY(93),
	    BLUE_HIGH_INTENSITY(94),
	    PURPLE_HIGH_INTENSITY(95),
	    CYAN_HIGH_INTENSITY(96),
	    WHITE_HIGH_INTENSITY(97),
	
	    // Background Colors
	    BLACK_BACKGROUND(40),
	    RED_BACKGROUND(41),
	    GREEN_BACKGROUND(42),
	    YELLOW_BACKGROUND(43),
	    BLUE_BACKGROUND(44),
	    PURPLE_BACKGROUND(45),
	    CYAN_BACKGROUND(46),
	    WHITE_BACKGROUND(47),
	
	    // High Intensity Background Colors
	    BLACK_HIGH_INTENSITY_BACKGROUND(100),
	    RED_HIGH_INTENSITY_BACKGROUND(101),
	    GREEN_HIGH_INTENSITY_BACKGROUND(102),
	    YELLOW_HIGH_INTENSITY_BACKGROUND(103),
	    BLUE_HIGH_INTENSITY_BACKGROUND(104),
	    PURPLE_HIGH_INTENSITY_BACKGROUND(105),
	    CYAN_HIGH_INTENSITY_BACKGROUND(106),
	    WHITE_HIGH_INTENSITY_BACKGROUND(107);
	
	
	
	
	    private final int code;
	    private int style = 0;
	
	    AnsiColor(int code) {
	        this.code = code;
	    }
	
	    public static String removeAnsiColors(String input) {
	        if (input == null) return null;
	        String ansiEscapeCodePattern = "\u001B\\[[;\\d]*[ -/]*[@-~]";
	        Pattern pattern = Pattern.compile(ansiEscapeCodePattern);
	        return pattern.matcher(input).replaceAll("");
	    }
	
	    public AnsiColor BOLD() {
	        this.style = 1;
	        return this;
	    }
	
	    public AnsiColor DIM() {
	        this.style = 2;
	        return this;
	    }
	
	    public AnsiColor ITALIC() {
	        this.style = 3;
	        return this;
	    }
	
	    public AnsiColor UNDERLINED() {
	        this.style = 4;
	        return this;
	    }
	
	    public AnsiColor BLINKING() {
	        this.style = 5;
	        return this;
	    }
	
	    public AnsiColor INVERTED() {
	        this.style = 7;
	        return this;
	    }
	
	    public AnsiColor HIDDEN() {
	        this.style = 8;
	        return this;
	    }
	
	    public AnsiColor STRIKE_THROUGH() {
	        this.style = 9;
	        return this;
	    }
	
	    public AnsiColor BOLD_UNDERLINE() {
	        this.style = 21;
	        return this;
	    }
	
	
	    @Override
	    public String toString() {
	        return build(code, style);
	    }
	
	    public static String build(int colorCode, int styleCode) {
	        return "\u001B[" + styleCode + ";" + colorCode + "m";
	    }
	
	}

	public static class DefaultFormatter implements Formatter {
	
	
	    @Override
	    public String format(String message) {
	        return getTimeStamp() + " " + message;
	    }
	
	    @Override
	    public String getTimeStamp() {
	        return Formatter.super.getTimeStamp();
	    }
	}

}