package pickbox;

import java.util.Arrays;
import java.lang.reflect.Field;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.lang.reflect.Modifier;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Collection;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.time.temporal.Temporal;
import java.util.Map.Entry;
import java.time.LocalDate;


/**
 * This file was generated by OneFile
 *
 * Repository: PickBoxRepo
 *
 * This file contains all the classes in the repository
 */
public class PickBoxRepo {

	/**
	 * <pre>
	 * This static interface is what you need to implement in order for PickPoint to work it's magic.
	 * 
	 * If the request specifies that it needs the object this resolver provides, then the
	 * resolve method will be invoked on your implementation of this interface.
	 * 
	 * PickPoint let's you split apart your object into pieces, and only do the work
	 * to get the pieces when the requests asks for it. Implementing this static class allows you
	 * to provide the piece when PickPoint requests it. 
	 * 
	 * T type is what the resolver outputs
	 * P is the parent object that will be provided to this resolver. (Use Object if it will not have a parent)
	 * E is the type of the extra data provided to the resolver when called. (Use Object if not needed)
	 * 
	 * </pre>
	 */
	public abstract static class Resolver<T, P, E> {
	
	    
	    /**
	     * 
	     * This method is called internally by PickPoint to get an object if the request speicifes
	     * that it needs it.
	     * 
	     * The parent is provided for all nested objects by PickPoint. eg, a University object
	     * that your Student object belongs too, will be provided in the Student resolver. For most
	     * object (any that aren't nested) the parent will just be null.
	     * 
	     * @param parent the parent of this object if applicable
	     * @param extraData some object you provide to PickPoint, given to all resolvers
	     * @return
	     */
	    public abstract T resolve(P parent, E extraData);
	
	
	
	
	    @SuppressWarnings("unchecked")
	    public Class<E> getArgType() {
	        ParameterizedType superclassType = (ParameterizedType) this.getClass().getGenericSuperclass();
	        return (Class<E>) superclassType.getActualTypeArguments()[2];
	    }
	
	
	    @SuppressWarnings("unchecked")
	    public Class<P> getParentType() {
	        ParameterizedType superclassType = (ParameterizedType) this.getClass().getGenericSuperclass();
	        return (Class<P>) superclassType.getActualTypeArguments()[1];
	    }
	
	
	
	    public String getReturnTypeName() {
	        ParameterizedType superclassType = (ParameterizedType) this.getClass().getGenericSuperclass();
	        Type returnType = superclassType.getActualTypeArguments()[0];
	
	        return buildReturnTypeNameFromType(returnType);
	    }
	
	
	    public static String buildResolverReturnTypeName(Class<?> type) {
	        return buildReturnTypeNameFromType(type);
	    }
	
	
	    public static String buildResolverReturnTypeName(Field field) {
	        Type type = field.getGenericType();
	        return buildReturnTypeNameFromType(type);
	    }
	
	    
	
	    private static String buildReturnTypeNameFromType(Type type) {
	
	        if (type instanceof ParameterizedType paramType) {
	            StringBuilder stringBuilder = new StringBuilder();
	
	            stringBuilder.append(paramType.getRawType());
	            for (Type t : paramType.getActualTypeArguments()) 
	                stringBuilder.append(" ").append(t.getTypeName());
	
	            return stringBuilder.toString();
	        }
	        else {
	            return type.getTypeName();
	        }
	        
	    }
	
	
	    
	}

	public static class TypeUtil {
	    
	    @SuppressWarnings("unchecked")
	    public static <T> T makeWithNoArgsConstructor(Class<?> type) {
	
	        T instance;
	        try {
	            instance = (T) type.getDeclaredConstructor().newInstance();
	        } catch (ReflectiveOperationException e) {
	            throw new PickerException("Missing default constructor in static class " + type.getName(), e);
	        }catch (ClassCastException e) {
	            throw new PickerException("Unexpected error when trying to create static class " + type.getName(), e);
	        }
	
	        return instance;
	    }
	
	
	
	    /**
	     * Tries to cast the object to the desired type. Throwing an exception if not possible.
	     *
	     * @param obj object to cast
	     * @param desiredType type to cast too
	     * @return cast object of type T
	     * @param <T> type
	     */
	    public static <T> T safeCast(Object obj, Class<T> desiredType) {
	        if (desiredType.isInstance(obj)) {
	            return desiredType.cast(obj);
	        }
	        String message = "Failed trying to cast static class " + obj.getClass().getName() + " to " + desiredType.getName();
	        throw new PickerException(message, null);
	    }
	
	
	    public static Object buildDefaultForNonBasicClass(Class<?> type) {
	
	        Object instance;
	        try {
	            instance = type.getDeclaredConstructor().newInstance();
	        } catch (ReflectiveOperationException e) {
	            throw new PickerException("Missing default constructor in static class " + type.getName(), e);
	        }
	
	        for (Field field : type.getDeclaredFields()) {
	            try {
	                boolean isPrivate = !Modifier.isPublic(field.getModifiers());
	                if (isPrivate)
	                    field.setAccessible(true);
	                Object value = (isBasicType(field.getType()))? 
	                    buildDefaultForJavaClass(field.getGenericType()) : 
	                    buildDefaultForNonBasicClass(field.getType());
	                field.set(instance, value);
	                if (isPrivate)
	                    field.setAccessible(false);
	            } catch (IllegalArgumentException e) {
	                throw new PickerException("Tried to map bad value to field " + field.getName() + "", e);
	            } catch (IllegalAccessException e) {
	                throw new PickerException("Couldn't access field " + field.getName() + "", e);
	            }
	        }
	
	        return instance;
	    }
	
	    public static Object buildDefaultForJavaClass(Type generic) {
	        Type screened = (generic instanceof ParameterizedType parameterizedType)? parameterizedType.getRawType() : generic;
	        Class<?> type = (Class<?>) screened;
	        Object defaultObject;
	        if (type == String.class) {
	            defaultObject = "";
	        }
	        else if (type == Integer.class || type == int.class) {
	            defaultObject = Integer.parseInt("0");
	        }
	        else if (type == Long.class || type == long.class) {
	            defaultObject = Long.parseLong("0");
	        }
	        else if (type == Double.class || type == double.class) {
	            defaultObject = Double.parseDouble("0.0");
	        }
	        else if (type == Float.class || type == float.class) {
	            defaultObject = Float.parseFloat("0.0");
	        }
	        else if (type == Short.class || type == short.class) {
	            defaultObject = Short.parseShort("0");
	        }
	        else if (type == Byte.class || type == byte.class) {
	            defaultObject = Byte.parseByte("0");
	        }
	        else if (type == Character.class || type == char.class) {
	            defaultObject = "a";
	        }
	        else if (type == BigDecimal.class) {
	            defaultObject = BigDecimal.valueOf( Long.parseLong("0") );
	        }
	        else if (type == Boolean.class || type == boolean.class) {
	            defaultObject = false;
	        }
	        else if (type.isEnum()) {
	            defaultObject = type.getEnumConstants()[0];
	        }
	        else if (Map.class.isAssignableFrom(type)) {
	            Class<?> keyType = null;
	            if (generic instanceof ParameterizedType) {
	                keyType = (Class<?>) ((ParameterizedType) generic).getActualTypeArguments()[0];
	            }
	            else {
	                keyType = Object.class;
	            }
	
	            Class<?> valueType = null;
	            if (generic instanceof ParameterizedType) {
	                valueType = (Class<?>) ((ParameterizedType) generic).getActualTypeArguments()[1];
	            }
	            else {
	                valueType = Object.class;
	            }
	
	            Object key = (isBasicType(keyType))? buildDefaultForJavaClass(keyType) : buildDefaultForNonBasicClass(keyType);
	            Object value = (isBasicType(valueType))? buildDefaultForJavaClass(valueType) : buildDefaultForNonBasicClass(valueType);
	
	            defaultObject = Map.of(key, value);
	        }
	        else if (Collection.class.isAssignableFrom(type)) {
	            Class<?> listType = null;
	            if (generic instanceof ParameterizedType) {
	                listType = (Class<?>) ((ParameterizedType) generic).getActualTypeArguments()[0];
	            }
	            else {
	                listType = Object.class;
	            }
	            Object instance = (isBasicType(listType))? buildDefaultForJavaClass(listType) : buildDefaultForNonBasicClass(listType);
	            defaultObject = List.of(instance);
	        }
	        else if (Temporal.class.isAssignableFrom(type)) {
	            try {
	                defaultObject = type.getMethod("now").invoke(null);
	            } catch (ReflectiveOperationException e) {
	                defaultObject = LocalDate.now();
	            }
	        }
	        else if (type == Object.class) {
	            defaultObject = new Object();
	        }
	        else {
	            throw new PickerException("Unsupported java type: " + type.getName(), null);
	        }
	
	        return defaultObject;
	    }
	
	
	
	    public static boolean isBasicType(Class<?> type) {
	        return isBasicJavaType(type) || isSupportedCollectionType(type) || type.isEnum();
	    }
	
	    /**
	     * Determines if a type is one of the following:
	     * - String
	     * - Date types
	     * - Numeric Types
	     * @param type
	     * @return
	     */
	    public static boolean isBasicJavaType(Class<?> type) {
	        return isNumericClass(type) || Temporal.class.isAssignableFrom(type) || type == String.class || isBoolean(type);
	    }
	
	    public static boolean isBoolean(Class<?> type) {
	        return type == Boolean.class || type == boolean.class;
	    }
	
	    public static boolean isNumericClass(Class<?> type) {
	        return Number.class.isAssignableFrom(type) || isPrimitiveNumericClass(type);
	    }
	
	    public static boolean isPrimitiveNumericClass(Class<?> type) {
	        return type == int.class || type == long.class || type == double.class
	                || type == float.class || type == short.class || type == byte.class;
	    }
	
	    public static boolean isSupportedCollectionType(Class<?> type) {
	        return Map.class.isAssignableFrom(type) || Collection.class.isAssignableFrom(type);
	    }
	
	
	}

	public static class PickerException extends RuntimeException {
	    public PickerException(String message, Exception cause) {
	        super(message, cause);
	    }
	}

	public static class PickerUtil {
	    
	
	
	    /**
	     * Converts an object to a map ommiting null fields
	     * 
	     * @param object
	     * @return
	     */
	    public static <T> Map<String, Object> mapify(T object) {
	
	        Map<String, Object> mappedResponse = new HashMap<>();
	        
	        Class<?> objectType = object.getClass();
	
	        Field[] fields = objectType.getFields();
	
	        for (Field field : fields) {
	            
	            try {
	                boolean originalAccessibility = field.canAccess(object);
	                field.setAccessible(true);
	
	
	                if (field.get(object) != null) {
	
	                    Object value = null;
	    
	                    // check if the field is a list
	                    if (List.class.isAssignableFrom(field.getType())) {
	                        List<Object> list = new ArrayList<>();
	
	                        Object fieldResponse = field.get(object);
	
	                        List<?> resList = TypeUtil.safeCast(fieldResponse, List.class);
	                        for (Object o : resList) {
	                            Object val = (TypeUtil.isBasicJavaType(o.getClass()) || o.getClass().isEnum())? o : mapify(o);
	                            list.add(val);
	                        }
	                        value = list;
	                    }
	                    // check if the field is a map
	                    else if (Map.class.isAssignableFrom(field.getType())) {
	                        Map<Object, Object> map = new HashMap<>();
	
	                        Map<?, ?> resMap = TypeUtil.safeCast(field.get(object), Map.class);
	                        for (Entry<?, ?> entry : resMap.entrySet()) {
	                            Object key = entry.getKey();
	                            Object val = entry.getValue();
	                            val = (TypeUtil.isBasicJavaType(val.getClass()) || val.getClass().isEnum())? val : mapify(val);
	                            map.put(key, val);
	                        }
	
	                        value = map;
	                    }
	                    // check if the field is a basic java type or enum
	                    else if (TypeUtil.isBasicJavaType(field.getType()) || field.getType().isEnum()) {
	                        value = field.get(object);
	                    }
	                    // otherwise we need to fulfill it as well
	                    else {
	                        Object fieldResponse = field.get(object);
	                        value = mapify(fieldResponse);
	                    }
	
	
	                    mappedResponse.put(field.getName(), value);
	    
	                }
	                field.setAccessible(originalAccessibility);
	                
	            } catch (IllegalArgumentException e) {
	                throw new PickerException("Tried to map bad value to field '" + field.getName() + "' in static class '" + objectType.getName() + "'", e);
	            }  catch (IllegalAccessException e) {
	                throw new PickerException("Couldn't access field '" + field.getName() + "' in static class '" + objectType.getName() + "'", e);
	            } 
	        }
	
	        return mappedResponse;
	    }
	
	
	    /**
	     * Converts a map to a pretty json string
	     */
	    public static String jsonMap(Map<String, Object> map) {
	        StringBuilder builder = new StringBuilder();
	        builder.append("{\n");
	
	        for (Entry<String, Object> entry : map.entrySet()) {
	
	            if (entry.getValue() instanceof Map) {
	                builder.append("\t\"").append(entry.getKey()).append("\": ");
	                String mapString = jsonMap((Map<String, Object>) entry.getValue());
	                String[] lines = mapString.split("\n");
	
	                builder.append("\t").append(lines[0]).append("\n");
	                String[] otherLines = Arrays.copyOfRange(lines, 1, lines.length);
	                for (String line : otherLines) {
	                    builder.append("\t").append(line).append("\n");
	                }
	
	            } 
	            else if (entry.getValue() instanceof List) {
	                builder.append("\t\"").append(entry.getKey()).append("\": ");
	                List<?> list = (List<?>) entry.getValue();
	                builder.append("[\n");
	                for (Object o : list) {
	                    if (o instanceof Map) {
	                        String mapString = jsonMap((Map<String, Object>) o);
	                        String[] lines = mapString.split("\n");
	
	                        builder.append("\t\t").append(lines[0]).append("\n");
	                        String[] otherLines = Arrays.copyOfRange(lines, 1, lines.length);
	                        for (String line : otherLines) {
	                            builder.append("\t\t").append(line).append("\n");
	                        }
	                        builder.deleteCharAt(builder.length() - 1);
	                        builder.append(",\n");
	                    } 
	                    else if (o instanceof List) {
	                        throw new PickerException("Double nested lists aren't supported for jsonMap conversion. Map key: " + entry.getKey(), null);
	                    }
	                    else if (o instanceof String || o.getClass().isEnum()) {
	                        builder.append("\"").append(o).append("\"").append(",\n");
	                    }
	                    else {
	                        builder.append(entry.getValue()).append(",\n");
	                    }
	                }
	                builder.deleteCharAt(builder.length() - 2);
	                builder.append("\t],\n");	
	            }
	            else {
	                builder.append("\t\"").append(entry.getKey()).append("\": ");
	                if (entry.getValue() instanceof String || entry.getValue().getClass().isEnum()) {
	                    builder.append("\"").append(entry.getValue()).append("\"").append(",\n");
	                }
	                else {
	                    builder.append(entry.getValue()).append(",\n");
	                }
	            }
	
	        }
	
	        builder.deleteCharAt(builder.length() - 2);
	        builder.append("}");
	
	        return builder.toString();
	    }
		
	
	}

	/**
	 * <pre>
	 * This static class is an object that handles the request object, and extracts 
	 * only the provided fields for the client from your provided object. 
	 * 
	 * This allows you to have graphql esk functionality without all the magic
	 * and baggage. 
	 * 
	 * </pre>
	 */
	public static class PickBox {
	    
	    private Map<String, Resolver<?, ?, ?>> resolvers;
	
	
	    /**
	     * <pre>
	     * To make a functional PickerBox, provide a list of 
	     * Resolver implementations to provide the objects
	     * in a request. 
	     * 
	     * 
	     * </pre>
	     * @param resolvers
	     */
	    public PickBox(List<Resolver<?,?,?>> resolvers) {
	        this.resolvers = new HashMap<>();
	
	        for (Resolver<?,?,?> resolver : resolvers) {
	            this.resolvers.put(resolver.getReturnTypeName(), resolver);
	        }
	    }
	
	
	
	    /**
	     * <pre>
	     * Goes through the request object looking for any fields that are not null. 
	     * If a field is not null, (has any arbitrary value) then that field will be requested
	     * from the resolvers and created in the result. 
	     * 
	     * The type T must have a no args constructor for this to work. 
	     * 
	     * The extraData is an object needed for each 
	     * resolver to fulfill their piece of the request. Say
	     * to get a Person object you need an Id for the row in 
	     * your database. You would provide this as or in the object 'extraData'. 
	     * Then when PickerBox tries to fulfill the request, it will
	     * provide your resolvers with this object.
	     * 
	     * </pre>
	     * @param <T>
	     * @param <E>
	     * @param request the object with fields that need to be resolved
	     * @param extraData an object which will be given to resolvers to help fulfill the request (can be null)
	     * @return
	     */
	    @SuppressWarnings("unchecked")
	    public <T, E> T resolveRequest(T request, E extraData){
	        T response = (T) getResponseFromResolver(
	            Resolver.buildResolverReturnTypeName(request.getClass()), 
	            null,
	            extraData
	        );
	
	        return getRequestedFields(request, response, extraData);
	    }
	
	    private <T, E> T getRequestedFields(T request, T response, E extraData){
	
	        Class<?> objectType = request.getClass();
	        T mappedResponse = TypeUtil.makeWithNoArgsConstructor(objectType);
	
	        Field[] fields = objectType.getFields();
	
	        List<Field> nonBlockingFields = new ArrayList<>();
	        List<Field> resolverFields = new ArrayList<>();
	        
	        // determine which fields are done with resolvers and do those last
	        Arrays.stream(fields)
	            .forEach(field -> {
	                String resolverTypeName = Resolver.buildResolverReturnTypeName(field);
	                if (this.resolvers.containsKey(resolverTypeName)) 
	                    resolverFields.add(field);
	                else
	                    nonBlockingFields.add(field);
	            });
	
	        Field currentField = null;
	        try {
	            // do the non blocking (ie fields with defined resolvers) first
	            for (Field field : nonBlockingFields) {
	                boolean originalAccessibility = field.canAccess(request);
	                field.setAccessible(true);
	
	                currentField = field; // for errors below
	
	                field.set(
	                    mappedResponse, 
	                    resolveField(field, request, response, mappedResponse, extraData)
	                );
	                
	                field.setAccessible(originalAccessibility);
	            }
	            // then do fields using resolvers so most complete parent object can be provided
	            for (Field field : resolverFields) {
	                boolean originalAccessibility = field.canAccess(request);
	                field.setAccessible(true);
	
	                currentField = field; // for errors below
	
	                field.set(
	                    mappedResponse, 
	                    resolveField(field, request, response, mappedResponse, extraData)
	                );
	                
	                field.setAccessible(originalAccessibility);
	            }
	            
	        } catch (IllegalArgumentException e) {
	            throw new PickerException("Tried to map bad value to field '" + currentField.getName() + "' in static class '" + objectType.getName() + "'", e);
	        }  catch (IllegalAccessException e) {
	            throw new PickerException("Couldn't access field '" + currentField.getName() + "' in static class '" + objectType.getName() + "'", e);
	        } 
	        
	        return mappedResponse;
	    }
	
	    private <T, E> Object resolveField(Field field, T request, T response, T parent, E extraData) {
	
	        try {
	            if (field.get(request) == null) 
	                return null;
	
	                
	            Object value = null;
	
	            // check if response already provided the field
	            if (response == null) {
	                return value;
	            } 
	            else if (field.get(response) != null) {
	                value = field.get(response);
	            }
	            // check if the field is a list
	            else if (List.class.isAssignableFrom(field.getType())) {
	                List<Object> list = new ArrayList<>();
	
	                List<?> reqList = TypeUtil.safeCast(field.get(request), List.class);
	                if (reqList.isEmpty())
	                        throw new PickerException("List for field " + field.getName() + " was empty so fulfillment couldn't be completed.", null);
	
	                Object reqO = reqList.get(0);
	
	                Object fieldResponse = getResponseFromResolver(
	                    Resolver.buildResolverReturnTypeName(field), 
	                    parent,
	                    extraData
	                );
	
	                if (fieldResponse != null) {
	                    List<?> resList = TypeUtil.safeCast(fieldResponse, List.class);
	                    for (Object o : resList) {
	                        list.add(
	                            getRequestedFields(reqO, o, extraData)
	                        );
	                    }
	                    value = list;
	                }
	                else {
	                    value = new ArrayList<>();
	                }
	                
	            }
	            // check if the field is a map
	            else if (Map.class.isAssignableFrom(field.getType())) {
	                Map<Object, Object> map = new HashMap<>();
	
	                value = field.get(response);
	                if (value != null) {
	                    Map<?, ?> reqMap = TypeUtil.safeCast(field.get(response), Map.class);
	                    if (reqMap.isEmpty())
	                        throw new PickerException("Map for field " + field.getName() + " was empty so fulfillment couldn't be completed.", null);
	
	                    Object reqOVal = reqMap.values().iterator().next();
	
	                    Map<?, ?> resMap = TypeUtil.safeCast(field.get(response), Map.class);
	                    for (Entry<?, ?> entry : resMap.entrySet()) {
	                        Object key = entry.getKey();
	                        Object val = entry.getValue();
	                        val = getRequestedFields(reqOVal, val, extraData);
	                        map.put(key, val);
	                    }
	
	                    value = map;
	                }
	                else {
	                    value = new HashMap<>();
	                }
	            }
	            // check if the field is a basic java type or enum
	            else if (TypeUtil.isBasicJavaType(field.getType()) || field.getType().isEnum()) {
	                value = field.get(response);
	            }
	            // otherwise we need to fulfill it with a resolver
	            else {
	                Object fieldResponse = getResponseFromResolver(
	                        Resolver.buildResolverReturnTypeName(field.getType()), 
	                        parent,
	                        extraData
	                );
	                value = getRequestedFields(field.get(request), fieldResponse, extraData);
	            }
	
	            return value;
	        } catch (IllegalArgumentException e) {
	            throw new PickerException("Tried to map bad value to field '" + field.getName() + "' in static class '" + parent.getClass().getName() + "'", e);
	        }  catch (IllegalAccessException e) {
	            throw new PickerException("Couldn't access field '" + field.getName() + "' in static class '" + parent.getClass().getName() + "'", e);
	        } 
	    }
	
	    private Object getResponseFromResolver(String resolverTypeName, Object parent, Object extraData) {
	        if (!this.resolvers.containsKey(resolverTypeName))
	            return null;
	
	        Resolver<?,?,?> resolver = this.resolvers.get(resolverTypeName);
	
	        Class<?> parentType = resolver.getParentType();
	        if (parent != null && !parentType.isAssignableFrom(parent.getClass())) 
	            throw new PickerException(
	                "Parent for resolver " + resolver.getClass().getName() + 
	                " was expected to be of type " + parentType.getName()
	                + " but was of type " + extraData.getClass().getName(), 
	                null
	            );
	
	        Class<?> argType = resolver.getArgType();
	        if (extraData != null && !argType.isAssignableFrom(extraData.getClass())) 
	            throw new PickerException(
	                "Argument for resolver " + resolver.getClass().getName() + 
	                " was expected to be of type " + argType.getName()
	                + " but was of type " + extraData.getClass().getName(), 
	                null
	            );
	
	        return invokeResolver(resolver, parent, extraData);
	    }
	
	    private <T, U, E> T invokeResolver(Resolver<T, U, E> resolver, Object parent, Object extraData) {
	        return resolver.resolve(
	            resolver.getParentType().cast(parent),
	            resolver.getArgType().cast(extraData)
	        );
	    }
	
	
	
	    public static <T> T getDefaultObject(Class<T> type) {
	        Object result = (TypeUtil.isBasicJavaType(type))? 
	            TypeUtil.buildDefaultForJavaClass(type) : 
	            TypeUtil.buildDefaultForNonBasicClass(type);
	
	        if (type.isInstance(result)) {
	            return type.cast(result);
	        }
	        return null;
	    }
	
	}

}